\subsection{ISA}
\label{sec:isa}
As stated previously our MIPS implementation runs a subset of the MIPS instruction set. Some of the instructions are required by the exercise while two, namely JR and JAL, are implemented in addtion. The two jump instructions where chosen because they are essential if conventional functions are to be supported.

In MIPS all instructions have the same width, 32 bits, and can be categorized into three categories R-, I- and J-type instructions. The bit layout of each of the instruction types are given in the figures \ref{fig:rtype_format}, \ref{fig:itype_format} and \ref{fig:jtype_format}. The subset of instructions our processor supports falls within all of the three categories. 

\paragraph{R-Type instructions}
\input{figures/instructions/r_type}
R-Type instructions have a total of three register fields, aswell as a function and shift field. Following this R-Type instruction coding is used for ALU operations as they have one destination and two source registers. There are however exceptions, such as the JR (Jump Register) instruction that is encoded as a R-Type instruction even thought it is a jump instruction. The R-Type instructions our implementation supports are show in table~\ref{table:rtype_instructions}.

\begin{table}[h]
    \begin{tabular}{l|l|l|l}
    Phonetic & Operation & Opcode & Function \\

    \hline
    ADD \$rd, \$rs, \$rt & \$rd = \$rs + \$rd   & 000000 & 100000 \\
    SUB \$rd, \$rs, \$rt & \$rd = \$rs - \$rd   & 000000 & 100011 \\ 
    AND \$rd, \$rs, \$rt & \$rd = \$rs and \$rd & 000000 & 100100 \\ 
    OR  \$rd, \$rs, \$rt & \$rd = \$rs or \$rd  & 000000 & 100101 \\  
    SLT \$rd, \$rs, \$rt & if \$rs $<$ \$rt \$rd = 1 else \$rd = 0  & 000000 & 101010 \\ 
    JR  \$rs             & \$PC = \$rs          & 000000 & 001000 \\ 
    \hline
    \end{tabular}

    \caption{Supported R-Type instructions}
    \label{table:rtype_instructions}
\end{table}

\paragraph{I-Type instructions}
\input{figures/instructions/i_type}
I-Type instructions have half of the instruction word reserved for a immediate value, and hence only have room for two register designators. This encoding type is therefore used to map instructions that use immediate values, such as load immediate aswell as load and store word. The I-Type instructions our implementation supports are show in table~\ref{table:itype_instructions}.

\begin{table}[h]
    \begin{tabular}{l|l|l|l}

    Phonetic & Operation & Opcode \\
    \hline
    BEQ \$rs, \$rt, imm  & if \$rs == \$rt \$PC += 1 + imm & 000100 \\
    LUI \$rs, imm        & \$rs = imm $<<$ 16                & 001111 \\
    SW \$rt, imm(\$rs)   & mem[\$rs+imm] = \$rt            & 101011 \\
    LW \$rt, imm(\$rs)   & \$rt = mem[\$rs+imm]            & 100011 \\
    \hline
    
    \end{tabular}

    \caption{Supported I-Type instructions}
    \label{table:itype_instructions}
\end{table}

\paragraph{J-Type instructions}
\input{figures/instructions/j_type}
J-Type instructions have an even larger immediate field with a width of 26 bits. This encoding is mainly used to encode various jump instructions. The J-Type instructions our implementation supports are show in table~\ref{table:jtype_instructions}.

\begin{table}[h]
    \begin{tabular}{l|l|l|l}

    Phonetic & Operation & Opcode \\
    \hline
    J imm  & \$PC = (PC \& 0xf0000000) | (imm $<<$ 2) & 000010 \\
    JAL imm  & \$31 = PC + 1 \$PC = (PC \& 0xf0000000) | (imm $<<$ 2) & 000011 \\
    \hline
    
    \end{tabular}

    \caption{Supported J-Type instructions}
    \label{table:jtype_instructions}
\end{table}
