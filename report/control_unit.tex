\subsection*{Control Unit}

The control unit is in many ways the brain within our processor implementation. It is responsable for controlling how the data path behaves during the execution of the program. It does so by controlling a total of 9 different control signals. Figure Y shows a black box diagram of the control unit with only the input and output signals.

In essence it is implemented as two parts, a syncronous state machine that updates the internal state of the control unit, and is an essensial part of a multi cycle design. The second sequential part that is responsible for driving all control signals, except for pc_latch driven by the state machine, is explained in detail later. The state machine have 4 possible states, RESET, FETCH, EXECUTE and STALL. Figure X shows the four states, the transition conditions and the effect the transitions have on the pc_latch control signal. In an effort to keep the figure as simple as possible the fact that transitions happen only on the rising edge of the clock and only if the enable signal is asserted has been hidden from the transition conditions.

The RESET state is a special state the processor only enters when the reset signal on the PLB bus is asserted, it is also the default state of the processor. It should be noted that the reset transitions have a higher priority than the others, hence if the reset signal is high the unit is forced into the RESET state.

The FETCH state is where the control unit is waiting for the next instruction to be fetched from the instruction memory. Upon entering this state from any other state than RESET the control signal pc_latch is asserted, signaling that the PC register should latch its next value. The reason why latching is not done when comming from RESET is because the PC at that point is zero, toggling the pc_latch would make it increment to 1 and hence always skipping the first instruction. As the instruction memory is synchronous the next instruction is available on the next rising click edge, so the transition to EXECUTE is condition less.

The EXECUTE state is where the work is done, upon entering this state the instruction word is ready, and the control unit has to decode it and drive all the control signals to their correct value. This decoding is done by the sequential part of the control unit. On the next clock edge the control unit enters either STALL or EXECUTE depending on whether or not the instruction being executed has to access the data memory. If the instruction does access data memory we need to stall for a cycle and the transtion to STALL is taken, if not the control unit enters FETCH again.

The STALL state does nothing but holding the control signals asserted by EXECUTE, this is because the data memory is synchronous aswell and after setting up the data path in EXECUTE we need to wait an additional clock cycle before the data has been written or the data to be read is available on the data out bus of the memory. From STALL there is a conditonless transtion back to FETCH.

The second part of the control unit is a sequential circut that based on the current internal state of the unit aswell as the current opcode drives the control signals. An overview of the inputs and corresponding outputs can be found in table X. A more indepth explanation of what the different control singals do is given in the section covering the overall processor architecture. The most importan thing to note is that in the FETCH state all destructive singals, signals that will cause data to be written, is pulled low. This is really important because upon entering EXECUTE the datapath will be unstable while signals propagate, and if a destrutive signal is high at that point grabage might be written to the registers or the memory.
